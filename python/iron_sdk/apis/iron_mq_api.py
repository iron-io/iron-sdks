#!/usr/bin/env python
# coding: utf-8

"""
IronMQApi.py
Copyright 2015 Reverb Technologies, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
"""
from __future__ import absolute_import

import sys
import os

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient

class IronMQApi(object):

    def __init__(self, token, host="https://mq-aws-us-east-1-1.iron.io/3/projects"):
        self.api_client = ApiClient(token, host=host)

    
    def get_queues(self, project_id, opts={}):
        """
        
        Get a list of all queues in a project in alphabetical order

        :param str project_id: The project that the queues belong to (required)
        :param int per_page: Number of elements returned per request 
        :param str previous: If previous is empty, the list will return from the beginning. Other wise, it will start on the next queue after previous\n 
        :param str prefix: List queues starting with a certain prefix 
        
        :return: QueueList
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `get_queues`")
        
        all_params = ['project_id', 'per_page', 'previous', 'prefix']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        query_params = {}
        
        if 'per_page' in params:
            query_params['per_page'] = params['per_page']
        
        if 'previous' in params:
            query_params['previous'] = params['previous']
        
        if 'prefix' in params:
            query_params['prefix'] = params['prefix']
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='QueueList', auth_settings=auth_settings)
        
        return response
        
    def get_queue_by_name(self, project_id, queue_name, opts={}):
        """
        
        Get a queue's info

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the queue (required)
        
        :return: QueueDataResponse
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `get_queue_by_name`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `get_queue_by_name`")
        
        all_params = ['project_id', 'queue_name']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='QueueDataResponse', auth_settings=auth_settings)
        
        return response
        
    def put_new_queue(self, project_id, queue_name, opts={}):
        """
        
        Create a new queue

        :param str project_id: The project that the new queue will belong to. (required)
        :param str queue_name: Name of the new queue. (required)
        :param QueueInfo queue: All fields are optional. 
        
        :return: QueueInfoResponse
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `put_new_queue`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `put_new_queue`")
        
        all_params = ['project_id', 'queue_name', 'queue']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}'.replace('{format}', 'json')
        method = 'PUT'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='QueueInfoResponse', auth_settings=auth_settings)
        
        return response
        
    def delete_queue(self, project_id, queue_name, opts={}):
        """
        
        Delete a queue

        :param str project_id: The project that the queue belongs to (required)
        :param str queue_name: Name of queue to be deleted (required)
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `delete_queue`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `delete_queue`")
        
        all_params = ['project_id', 'queue_name']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def update_queue(self, project_id, queue_name, opts={}):
        """
        
        Update a queue's information.

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the queue (required)
        :param QueueInfo queue: The queue's options to be changed. Some fields will not be included if they are not applicable, such as push if it's not a push queue or alerts if there are no alerts 
        
        :return: QueueInfoResponse
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `update_queue`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `update_queue`")
        
        all_params = ['project_id', 'queue_name', 'queue']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}'.replace('{format}', 'json')
        method = 'PATCH'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='QueueInfoResponse', auth_settings=auth_settings)
        
        return response
        
    def put_alerts(self, project_id, queue_name, opts={}):
        """
        
        Replaces the existing alerts with a new list. Only available for pull queues.

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the pull queue (required)
        :param AlertList alerts: Set of alerts 
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `put_alerts`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `put_alerts`")
        
        all_params = ['project_id', 'queue_name', 'alerts']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/alerts'.replace('{format}', 'json')
        method = 'PUT'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def add_alert(self, project_id, queue_name, opts={}):
        """
        
        Add an alert to a queue. Only available for pull queues.

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the pull queue (required)
        :param AlertList alerts: Set of alerts 
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `add_alert`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `add_alert`")
        
        all_params = ['project_id', 'queue_name', 'alerts']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/alerts'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def delete_alerts(self, project_id, queue_name, opts={}):
        """
        
        Delete a batch of alerts from a queue. Only available for pull queues.

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the pull queue (required)
        :param AlertList alerts: Set of alert IDs to be deleted 
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `delete_alerts`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `delete_alerts`")
        
        all_params = ['project_id', 'queue_name', 'alerts']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/alerts'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def delete_alert_by_id(self, project_id, queue_name, alert_id, opts={}):
        """
        
        Delete a single alert from a queue using its ID. Only available for pull queues.

        :param str project_id: The project that the pull queue belongs to. (required)
        :param str queue_name: The name of the pull queue (required)
        :param str alert_id: ID of the alert to be deleted (required)
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `delete_alert_by_id`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `delete_alert_by_id`")
        
        # verify the required parameter 'alert_id' is set
        if alert_id is None:
            raise ValueError("Missing the required parameter `alert_id` when calling `delete_alert_by_id`")
        
        all_params = ['project_id', 'queue_name', 'alert_id']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/alerts/{alert_id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        if 'alert_id' in params:
            path_params['alert_id'] = params['alert_id']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def get_messages(self, project_id, queue_name, opts={}):
        """
        
        Peek messages on a queue

        :param str project_id: The project that the queue belongs to (required)
        :param str queue_name: The name of the queue that you want to peek from (required)
        :param int n: The amount of messages you want to peek, defaults to 1 
        
        :return: MessageList
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `get_messages`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `get_messages`")
        
        all_params = ['project_id', 'queue_name', 'n']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/messages'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        if 'n' in params:
            query_params['n'] = params['n']
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='MessageList', auth_settings=auth_settings)
        
        return response
        
    def post_messages(self, project_id, queue_name, opts={}):
        """
        
        Add a set of messages to a single queue. Multiple messages may be added in a single request, provided that the messages should all be added to the same queue.

        :param str project_id: The project that the queue belong's to. (required)
        :param str queue_name: Name of the queue that the messages are being added to. (required)
        :param MessagePostDataList messages:  
        
        :return: MessageIdList
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `post_messages`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `post_messages`")
        
        all_params = ['project_id', 'queue_name', 'messages']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/messages'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='MessageIdList', auth_settings=auth_settings)
        
        return response
        
    def delete_messages(self, project_id, queue_name, opts={}):
        """
        
        Clear all messages from a queue or batch delete messages. This does not delete the queue.

        :param str project_id: The project that the queue belongs to. (required)
        :param str queue_name: Name of the queue. (required)
        :param DeleteMsgList messages: A list of messages to be deleted. If the request is empty, all messages on the queue will be removed.\n 
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `delete_messages`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `delete_messages`")
        
        all_params = ['project_id', 'queue_name', 'messages']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/messages'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def get_message_by_id(self, project_id, queue_name, message_id, opts={}):
        """
        
        Get the info on a particular message in a queue

        :param str project_id: The project that the queue belongs to. (required)
        :param str queue_name: The name of the queue. (required)
        :param str message_id: ID of the message (required)
        
        :return: SingleMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `get_message_by_id`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `get_message_by_id`")
        
        # verify the required parameter 'message_id' is set
        if message_id is None:
            raise ValueError("Missing the required parameter `message_id` when calling `get_message_by_id`")
        
        all_params = ['project_id', 'queue_name', 'message_id']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/messages/{message_id}'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        if 'message_id' in params:
            path_params['message_id'] = params['message_id']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='SingleMessage', auth_settings=auth_settings)
        
        return response
        
    def delete_message_by_id(self, project_id, queue_name, message_id, opts={}):
        """
        
        Delete a message off the queue

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the queue (required)
        :param str message_id: ID of the message (required)
        :param DeleteMsg message:  
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `delete_message_by_id`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `delete_message_by_id`")
        
        # verify the required parameter 'message_id' is set
        if message_id is None:
            raise ValueError("Missing the required parameter `message_id` when calling `delete_message_by_id`")
        
        all_params = ['project_id', 'queue_name', 'message_id', 'message']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/messages/{message_id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        if 'message_id' in params:
            path_params['message_id'] = params['message_id']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def release_message_by_id(self, project_id, queue_name, message_id, body, opts={}):
        """
        
        Places a reserved message back on the queue after a delay.

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the queue (required)
        :param str message_id: ID of the message (required)
        :param Release body:  (required)
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `release_message_by_id`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `release_message_by_id`")
        
        # verify the required parameter 'message_id' is set
        if message_id is None:
            raise ValueError("Missing the required parameter `message_id` when calling `release_message_by_id`")
        
        # verify the required parameter 'body' is set
        if body is None:
            raise ValueError("Missing the required parameter `body` when calling `release_message_by_id`")
        
        all_params = ['project_id', 'queue_name', 'message_id', 'body']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/messages/{message_id}/release'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        if 'message_id' in params:
            path_params['message_id'] = params['message_id']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def get_subscriber_status_by_message_id(self, project_id, queue_name, message_id, opts={}):
        """
        
        Checks the push statuses across all subscribers for a message

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the queue (required)
        :param str message_id: ID of the message (required)
        
        :return: PushStatusList
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `get_subscriber_status_by_message_id`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `get_subscriber_status_by_message_id`")
        
        # verify the required parameter 'message_id' is set
        if message_id is None:
            raise ValueError("Missing the required parameter `message_id` when calling `get_subscriber_status_by_message_id`")
        
        all_params = ['project_id', 'queue_name', 'message_id']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/messages/{message_id}/subscribers'.replace('{format}', 'json')
        method = 'GET'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        if 'message_id' in params:
            path_params['message_id'] = params['message_id']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='PushStatusList', auth_settings=auth_settings)
        
        return response
        
    def touch_message_by_id(self, project_id, queue_name, message_id, opts={}):
        """
        
        Creates a new reservation for a message.

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the queue (required)
        :param str message_id: ID of the message (required)
        :param Touch message:  
        
        :return: TouchResponse
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `touch_message_by_id`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `touch_message_by_id`")
        
        # verify the required parameter 'message_id' is set
        if message_id is None:
            raise ValueError("Missing the required parameter `message_id` when calling `touch_message_by_id`")
        
        all_params = ['project_id', 'queue_name', 'message_id', 'message']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/messages/{message_id}/touch'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        if 'message_id' in params:
            path_params['message_id'] = params['message_id']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='TouchResponse', auth_settings=auth_settings)
        
        return response
        
    def reserve_messages(self, project_id, queue_name, opts={}):
        """
        
        Reserve n amounts of messages from a queue

        :param str project_id: The project that the queue belongs to (required)
        :param str queue_name: Name of the queue (required)
        :param ReservationRequest options: n: The maximum number of messages to get. Default is 1. Maximum is 100. Note: You may not receive all n messages on every request, the more sparse the queue, the less likely you are to receive all n messages.\ntimeout: After timeout (in seconds), item will be placed back onto queue. You must delete the message from the queue to ensure it does not go back onto the queue. If not set, value from queue is used. Default is 60 seconds, minimum is 30 seconds, and maximum is 86,400 seconds (24 hours).\nwait: Time to long poll for messages, in seconds. Max is 30 seconds. Default 0.\ndelete: swagger\n 
        
        :return: ReservationResponse
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `reserve_messages`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `reserve_messages`")
        
        all_params = ['project_id', 'queue_name', 'options']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/reservations'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ReservationResponse', auth_settings=auth_settings)
        
        return response
        
    def put_subscribers(self, project_id, queue_name, subscribers, opts={}):
        """
        
        Replaces the current subscribers on a push queue with a new list of subscribers Older subscribers will be removed.\n

        :param str project_id: The project that the queues belong to. (required)
        :param str queue_name: Name of the push queue. (required)
        :param SubscriberList subscribers: A list of subscribers that will be replacing the current list. (required)
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `put_subscribers`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `put_subscribers`")
        
        # verify the required parameter 'subscribers' is set
        if subscribers is None:
            raise ValueError("Missing the required parameter `subscribers` when calling `put_subscribers`")
        
        all_params = ['project_id', 'queue_name', 'subscribers']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/subscribers'.replace('{format}', 'json')
        method = 'PUT'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def post_subscribers(self, project_id, queue_name, subscribers, opts={}):
        """
        
        Add a new subscriber to a push queue or update an existing subscriber

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the push queue. (required)
        :param SubscriberList subscribers: A list of subscribers to be added or updated. (required)
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `post_subscribers`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `post_subscribers`")
        
        # verify the required parameter 'subscribers' is set
        if subscribers is None:
            raise ValueError("Missing the required parameter `subscribers` when calling `post_subscribers`")
        
        all_params = ['project_id', 'queue_name', 'subscribers']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/subscribers'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def delete_subscribers(self, project_id, queue_name, subscribers, opts={}):
        """
        
        Remove one or multiple subscribers from a push queue.

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the push queue (required)
        :param SubscriberList subscribers:  (required)
        
        :return: ResponseMessage
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `delete_subscribers`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `delete_subscribers`")
        
        # verify the required parameter 'subscribers' is set
        if subscribers is None:
            raise ValueError("Missing the required parameter `subscribers` when calling `delete_subscribers`")
        
        all_params = ['project_id', 'queue_name', 'subscribers']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/subscribers'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response='ResponseMessage', auth_settings=auth_settings)
        
        return response
        
    def post_webhook(self, project_id, queue_name, opts={}):
        """
        
        Send a set of messages to the webhook endpoint.

        :param str project_id: The project that the queues belong to (required)
        :param str queue_name: Name of the queue (required)
        :param MessagePostDataList messages:  
        
        :return: None
        """
        
        # verify the required parameter 'project_id' is set
        if project_id is None:
            raise ValueError("Missing the required parameter `project_id` when calling `post_webhook`")
        
        # verify the required parameter 'queue_name' is set
        if queue_name is None:
            raise ValueError("Missing the required parameter `queue_name` when calling `post_webhook`")
        
        all_params = ['project_id', 'queue_name', 'messages']

        params = locals()
        for key, val in iteritems(params['opts']):
            params[key] = val
        del params['opts']

        resource_path = '/{project_id}/queues/{queue_name}/webhook'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        
        if 'queue_name' in params:
            path_params['queue_name'] = params['queue_name']
        
        query_params = {}
        
        header_params = {}
        
        form_params = {}
        files = {}
        
        body_params = None
        
        body_params = opts
        
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type([])

        # Authentication setting
        auth_settings = ['oauth_token']

        response = self.api_client.call_api(resource_path, method, path_params, query_params, header_params,
                                            body=body_params, post_params=form_params, files=files,
                                            response=None, auth_settings=auth_settings)
        
